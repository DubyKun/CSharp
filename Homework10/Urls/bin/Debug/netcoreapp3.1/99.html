<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="referrer" content="origin-when-crossorigin" />
    <meta name="description" content="大家好，我是小羽。 Dubbo 起源于阿里巴巴，对于我们做电商开发的人来说，基本是首选的技术，那么为何一个区区 soa 服务治理框架，会受到这么多人的青睐呢？ 今天就跟着小羽一起看看这个微服务框架之一" />
    <meta property="og:description" content="大家好，我是小羽。 Dubbo 起源于阿里巴巴，对于我们做电商开发的人来说，基本是首选的技术，那么为何一个区区 soa 服务治理框架，会受到这么多人的青睐呢？ 今天就跟着小羽一起看看这个微服务框架之一" />
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>微服务面试必问的Dubbo，这么详细还怕自己找不到工作？ - 浅羽技术 - 博客园</title>
    <link id="favicon" rel="shortcut icon" href="//common.cnblogs.com/favicon.svg" type="image/svg+xml" />
    
    <link rel="stylesheet" href="/css/blog-common.min.css?v=zS6-e1bxywlu3kpHvpr1J6MySwya3ztFtEnS7RYQ0Fk" />
    <link id="MainCss" rel="stylesheet" href="/skins/codinglife/bundle-codinglife.min.css?v=2uJkpdACLVfstRQ7zeCFK19brTwKuDEaNBLgKz9nm3A" />
    
    <link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="/skins/codinglife/bundle-codinglife-mobile.min.css?v=DwDRKMd1bmjnJZ4iQqrTCO9QLlYb6OZaUAzHoHIIihg" />
    
    <link type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/qianyueric/rss" />
    <link type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/qianyueric/rsd.xml" />
    <link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/qianyueric/wlwmanifest.xml" />
    <script>
        var currentBlogId = 655084;
        var currentBlogApp = 'qianyueric';
        var cb_enable_mathjax = true;
        var isLogined = false;
        var isBlogOwner = false;
        var skinName = 'CodingLife';
        var visitorUserId = '';
    </script>
        <script>
            var currentPostDateAdded = '2021-03-29 11:33';
        </script>
    <script src="https://common.cnblogs.com/scripts/jquery-2.2.0.min.js"></script>
    <script src="/js/blog-common.min.js?v=yJQaJ16S00coMfzvh-NgF2zm2J87f5VfNamFdsnKHrc"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
        tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']], processClass: 'math', processEscapes: true },
        TeX: {
        equationNumbers: { autoNumber: ['AMS'], useLabelIds: true },
        extensions: ['extpfeil.js', 'mediawiki-texvc.js'],
        Macros: {bm: "\\boldsymbol"}
        },
        'HTML-CSS': { linebreaks: { automatic: true } },
        SVG: { linebreaks: { automatic: true } }
        });
    </script>
    <script src="https://mathjax.cnblogs.com/2_7_5/MathJax.js?config=TeX-AMS-MML_HTMLorMML&amp;v=20200504"></script>
    
</head>
<body class="has-navbar">
    <a name="top"></a>
    <div id="top_nav" class="navbar forpc">
        <nav id="nav_main" class="navbar-main">
            <ul id="nav_left" class="navbar-list navbar-left">
                <li class="navbar-branding"><a href="https://www.cnblogs.com/" title="开发者的网上家园"><img src="/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM" alt="博客园Logo" /></a></li>
                <li><a href="/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-sitehome')">首页</a></li>
                <li><a href="https://news.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-news')">新闻</a></li>
                <li><a href="https://q.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-q')">博问</a></li>
                <li><a id="nav_brandzone" href="https://brands.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-brands')">专区</a></li>
                <li><a href="https://ing.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-ing')">闪存</a></li>
                <li><a href="https://edu.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-edu')">班级</a></li>
            </ul>
            <ul id="nav_right" class="navbar-list navbar-right">
                <li>
                    <form id="zzk_search" class="navbar-search" action="https://zzk.cnblogs.com/s" method="get">
                        <input name="w" id="zzk_search_input" placeholder="代码改变世界" type="text" tabindex="3" />
                        <button type="submit" id="zzk_search_button">
                            <img src="/images/aggsite/search.svg" alt="搜索" />
                        </button>
                    </form>
                </li>
                <li id="navbar_login_status" class="navbar-list">
                    <a class="navbar-user-info navbar-blog" href="https://i.cnblogs.com/EditPosts.aspx?opt=1" alt="写随笔" title="写随笔">
                        <img id="new_post_icon" class="navbar-icon" src="/images/aggsite/newpost.svg" alt="写随笔" />
                    </a>
                    <a id="navblog-myblog-icon" class="navbar-user-info navbar-blog" href="https://passport.cnblogs.com/GetBlogApplyStatus.aspx" alt="我的博客" title="我的博客">
                        <img id="myblog_icon" class="navbar-icon" src="/images/aggsite/myblog.svg" alt="我的博客" />
                    </a>
                    <a class="navbar-user-info navbar-message navbar-icon-wrapper" href="https://msg.cnblogs.com/" alt="短消息" title="短消息">
                        <img id="msg_icon" class="navbar-icon" src="/images/aggsite/message.svg?v=J0WS2P2iPgaIVgXxcAhliw4AFZIpaTWxtdoNAv9eiCA" alt="短消息" />
                        <span id="msg_count" style="display: none"></span>
                    </a>
                    <div id="user_info" class="navbar-user-info dropdown">
                        <a class="dropdown-button" href="https://home.cnblogs.com/">
                            <img id="user_icon" class="navbar-avatar" src="/images/aggsite/avatar-default.svg" alt="用户头像" />
                        </a>
                        <div class="dropdown-menu">
                            <a id="navblog-myblog-text" href="https://passport.cnblogs.com/GetBlogApplyStatus.aspx">我的博客</a>
                            <a href="https://home.cnblogs.com/">我的园子</a>
                            <a href="https://account.cnblogs.com/settings/account">账号设置</a>
                            <a href="javascript:void(0)" id="navbar_lite_mode_toggle" title="简洁模式会使用简洁款皮肤显示所有博客">
    简洁模式 <img id="navbar_lite_mode_on" src="/images/lite-mode-check.svg" class="hide" /><span id="navbar_lite_mode_spinner" class="hide">...</span>
</a>
                            <a href="javascript:void(0)" onclick="account.logout();">退出登录</a>
                        </div>
                    </div>
                    <a class="navbar-anonymous" href="https://account.cnblogs.com/signup/">注册</a>
                    <a class="navbar-anonymous" href="javascript:void(0);" onclick="account.login()">登录</a>
                </li>
            </ul>
        </nav>
    </div>

    
    <!--done-->
<div id="home">
<div id="header">
	<div id="blogTitle">
        <a id="lnkBlogLogo" href="https://www.cnblogs.com/qianyueric/"><img id="blogLogo" src="/skins/custom/images/logo.gif" alt="返回主页" /></a>		
		
<!--done-->
<h1><a id="Header1_HeaderTitle" class="headermaintitle HeaderMainTitle" href="https://www.cnblogs.com/qianyueric/">浅羽技术</a>
</h1>
<h2>微信搜索并关注「 浅羽的IT小屋 」微信公众号，我会在这里分享一些计算机信息知识、理论技术、工具资源、软件介绍、后端开发、面试、工作感想以及生活随想等一系列文章。</h2>




		
	</div><!--end: blogTitle 博客的标题和副标题 -->
	<div id="navigator">
		
<ul id="navList">
<li><a id="blog_nav_sitehome" class="menu" href="https://www.cnblogs.com/">
博客园</a>
</li>
<li>
<a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/qianyueric/">
首页</a>
</li>
<li>

<a id="blog_nav_newpost" class="menu" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">
新随笔</a>
</li>
<li>
<a id="blog_nav_contact" class="menu" href="https://msg.cnblogs.com/send/%E6%B5%85%E7%BE%BD%E6%8A%80%E6%9C%AF">
联系</a></li>
<li>
<a id="blog_nav_rss" class="menu" href="javascript:void(0)" data-rss="https://www.cnblogs.com/qianyueric/rss/">
订阅</a>
<!--<partial name="./Shared/_XmlLink.cshtml" model="Model" /></li>--></li>
<li>
<a id="blog_nav_admin" class="menu" href="https://i.cnblogs.com/">
管理</a>
</li>
</ul>


		<div class="blogStats">
			<div id="blog_stats_place_holder"><script>loadBlogStats();</script></div>
		</div><!--end: blogStats -->
	</div><!--end: navigator 博客导航栏 -->
</div><!--end: header 头部 -->
<div id="main">
	<div id="mainContent">
	<div class="forFlow">
		<div id="post_detail">
    <!--done-->
    <div id="topics">
        <div class="post">
            <h1 class = "postTitle">
                
<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/qianyueric/p/14591684.html">
    <span>微服务面试必问的Dubbo，这么详细还怕自己找不到工作？</span>
    



</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://images.cnblogs.com/cnblogs_com/qianyueric/1958381/o_210408034216WechatIMG318.jpeg" class="desc_img">dubbo 起源于阿里巴巴，对于我们做电商开发的人来说，基本是首选的技术，那么为何一个区区 soa 服务治理框架，会受到这么多人的青睐呢？今天就跟着小羽一起看看这个微服务框架之一的 Dubbo 的详细解读吧。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p><strong>大家好，我是小羽。</strong></p>
<p>Dubbo 起源于阿里巴巴，对于我们做电商开发的人来说，基本是首选的技术，那么为何一个区区 soa 服务治理框架，会受到这么多人的青睐呢？</p>
<p>今天就跟着小羽一起看看这个微服务框架之一的 Dubbo 的详细解读吧。</p>
<h3 id="前言">前言</h3>
<p>互联网的不断发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对。</p>
<p>服务化的进一步发展，服务越来越多，服务之间的调用和依赖关系也越来越复杂，诞生了<strong>面向服务</strong>的架构体系(SOA)，</p>
<p>也因此衍生出了一系列相应的技术，如对服务提供、服务调用、连接处理、通信协议、序列化方式、服务发现、服务路由、日志输出等行为<strong>进行封装</strong>的服务框架。</p>
<p>就这样分布式系统的<strong>服务治理</strong>框架就出现了，Dubbo也就这样产生了。</p>
<h3 id="概念">概念</h3>
<p>Dubbo 是一款高性能、轻量级的开源 <code>RPC</code> 框架、提供服务自动注册、自动发现等高效治理方案，可以和 <code>Spring</code> 框架<strong>无缝集成</strong>。</p>
<p>简单的说，dubbo就是个分布式服务框架，在有分布式需要的时候可以使用 dubbo 的框架，使用 dubbo 的好处：</p>
<p>_1、_透明化的远程方法调用</p>
<p>_2、_软负载均衡及容错机制</p>
<p>_3、_服务自动注册与发现</p>
<p>_4、_提供了完善的服务接口管理与监控功能</p>
<p><img src="https://img2020.cnblogs.com/blog/1613154/202103/1613154-20210329110958024-1448061517.png" alt="image" loading="lazy"><br>
架构图</p>
<h3 id="rpc">RPC</h3>
<h4 id="简介">简介</h4>
<p>RPC 全称为 remote procedure call，即远程过程调用。比如两台服务器 A 和 B，A 服务器上部署一个应用，B 服务器上部署一个应用，A 服务器上的应用想调用 B 服务器上的应用提供的方法，由于两个应用不在一个内存空间，不能直接调用，所以需要通过网络来<strong>表达调用的语义和传达调用的数据</strong>。</p>
<p>RPC 并不是一个具体的技术，而是指整个网络<strong>远程调用过程</strong>。</p>
<p>RPC 是一个泛化的概念，严格来说一切远程过程调用手段都属于 RP C范畴。各种开发语言都有自己的 RPC 框架。Java 中的 RPC 框架比较多，广泛使用的有 <code>RMI、Hessian、Dubbo</code> 等。</p>
<h4 id="原理">原理</h4>
<p>服务消费方（client）调用以本地调用方式调用服务。客户端存根（client stub）接收到调用后负责将<strong>方法、参数</strong>等编码成能在网络中传输的消息体。然后，客户端存根找到服务地址后，将消息发送给服务端。</p>
<p>服务提供方（server）收到序列化后的消息，就按照解码该消息。然后，根据解码结果调用本地服务，执行完毕后，将结果<strong>打包发送</strong>给消费方。</p>
<p>服务消费方收到执行结果后，也是<strong>进行解码</strong>后得到结果。<br>
<img src="https://img2020.cnblogs.com/blog/1613154/202103/1613154-20210329111223335-1195513333.png" alt="image" loading="lazy"><br>
原理</p>
<h3 id="使用场景">使用场景</h3>
<p><em>RPC 分布式服务</em>，拆分应用进行服务化，提高开发效率，调优性能，节省竞争资源</p>
<p>_配置管理，_解决服务的地址信息剧增，配置困难的问题</p>
<p>_服务依赖，_解决服务间依赖关系错踪复杂的问题</p>
<p>_服务扩容，_解决随着访问量的不断增大，动态扩展服务提供方的机器的问题</p>
<h3 id="核心功能">核心功能</h3>
<p><code>Remoting</code>：远程通讯，提供对多种 NIO 框架<strong>抽象封装</strong>，包括“同步转异步”和“请求-响应”模式的信息交换方式。</p>
<p><code>Cluster</code>：服务框架，提供基于接口方法的<strong>透明远程过程调用</strong>，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。</p>
<p><code>Registry</code>：服务注册中心，服务自动发现: 基于注册中心目录服务，使服务消费方能<strong>动态的查找</strong>服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。</p>
<h3 id="核心组件">核心组件</h3>
<p>_Provider：_服务的提供方</p>
<p>_Consumer：_调用远程服务的服务消费方</p>
<p>_Registry：_服务注册和发现的注册中心</p>
<p>_Monitor：_统计服务调用次数和调用时间的监控中心</p>
<p>_Container：_服务运行容器<br>
<img src="https://img2020.cnblogs.com/blog/1613154/202103/1613154-20210329111400819-390164105.png" alt="image" loading="lazy"><br>
组件</p>
<h3 id="服务注册与发现">服务注册与发现</h3>
<p><em>流程如下：</em></p>
<p>_1、_Provider(提供者)<strong>绑定</strong>指定端口并启动服务</p>
<p>_2、_供者连接注册中心，并发本机 IP、端口、应用信息和提供服务信息发送至注册中心<strong>存储</strong></p>
<p>_3、_Consumer(消费者），连接注册中心 ，并<strong>发送</strong>应用信息、所求服务信息至注册中心</p>
<p>_4、_注册中心根据消费者所求服务信息<strong>匹配</strong>对应的提供者列表发送至Consumer 应用缓存。</p>
<p>_5、_Consumer 在发起远程调用时基于缓存的消费者列表择其一发起<strong>调用</strong>。</p>
<p>_6、_Provider 状态变更会实时通知注册中心、在由注册中心实时<strong>推送</strong>至Consumer设计的原因：</p>
<p>Consumer 与 Provider 解偶，双方都可以<strong>横向增减</strong>节点数。注册中心对本身可做对等集群，可动态增减节点，并且任意一台宕掉后，将<strong>自动切换</strong>到另一台</p>
<p>_7、_去中心化，双方<strong>不直接依懒</strong>注册中心，即使注册中心全部宕机短时间内也不会影响服务的调用</p>
<p>_8、_服务提供者<strong>无状态</strong>，任意一台宕掉后，不影响使用<br>
<img src="https://img2020.cnblogs.com/blog/1613154/202103/1613154-20210329111428334-1587562662.png" alt="image" loading="lazy"><br>
流程</p>
<h3 id="服务治理">服务治理</h3>
<h4 id="治理原因">治理原因</h4>
<p>Dubbo的服务治理主要原因：</p>
<p>_1、_过多的服务 URL <strong>配置困难</strong>。</p>
<p>_2、_负载均衡分配节点<strong>压力过大</strong>的情况下也需要部署集群。</p>
<p>_3、_服务<strong>依赖混乱</strong>，启动顺序不清晰。</p>
<p>_4、_过多服务导致性能指标<strong>分析难度较大</strong>，需要监控。</p>
<h4 id="主要特性">主要特性</h4>
<p>_透明远程调用：_就像调用本地方法一样调用远程方法；只需简单配置，没有任何 API 侵入</p>
<p>_负载均衡机制：_Client 端 LB，可在内网替代 F5 等硬件负载均衡器</p>
<p>_容错重试机制：_服务 Mock 数据，重试次数、超时机制等</p>
<p>_自动注册发现：_注册中心基于接口名查询服务提 供者的 IP 地址，并且能够平滑添加或删除服务提供者</p>
<p>_性能日志监控：_Monitor 统计服务的调用次调和调用时间的监控中心</p>
<p>_服务治理中心：_路由规则，动态配置，服务降级，访问控制，权重调整，负载均衡，等手动配置</p>
<p>_自动治理中心：_无，比如：熔断限流机制、自动权重调整等（因此可以搭配SpringCloud的熔断机制等进行开发）<br>
<img src="https://img2020.cnblogs.com/blog/1613154/202103/1613154-20210329111554247-61610291.png" alt="image" loading="lazy"><br>
服务治理</p>
<h3 id="架构设计">架构设计</h3>
<h4 id="整体架构">整体架构</h4>
<p>先看下 Dubbo 的整体架构图：</p>
<p>图例说明：<br>
<img src="https://img2020.cnblogs.com/blog/1613154/202103/1613154-20210329111619901-746641649.jpg" alt="image" loading="lazy"><br>
整体架构</p>
<p>图中左边淡蓝背景的为<strong>服务消费方</strong>使用的接口，右边淡绿色背景的为<strong>服务提供方</strong>使用的接口，位于中轴线上的为双方都用到的接口。</p>
<p>图中从下至上分为十层，各层均为<strong>单向依赖</strong>，右边的黑色箭头代表层之间的<strong>依赖关系</strong>，每一层都可以剥离上层被复用，其中，<code>Service</code> 和 <code>Config</code> 层为 API，其它各层均为 SPI。</p>
<p>图中绿色小块的为<strong>扩展接口</strong>，蓝色小块为<strong>实现类</strong>，图中只显示用于关联各层的实现类。</p>
<p>图中蓝色虚线为<strong>初始化过程</strong>，即启动时组装链，红色实线为<strong>方法调用过程</strong>，即运行时调时链，紫色三角箭头为<strong>继承</strong>，可以把子类看作父类的同一个节点，线上的文字为调用的方法。</p>
<h4 id="各层说明">各层说明</h4>
<p>_config 配置层：_对外配置接口，以 ServiceConfig, ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类</p>
<p>_proxy 服务代理层：_服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton,以ServiceProxy 为中心，扩展接口为 ProxyFactory</p>
<p>_registry 注册中心层：_封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为RegistryFactory, Registry, RegistryService</p>
<p>_cluster 路由层：_封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 Cluster, Directory, Router, LoadBalance</p>
<p>_monitor 监控层：_RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为MonitorFactory, Monitor, MonitorService</p>
<p>_protocol 远程调用层：_封装 RPC 调用，以 Invocation, Result 为中心，扩展接口为 Protocol, Invoker, Exporter</p>
<p>_exchange 信息交换层：_封装请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为 Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer</p>
<p>_transport 网络传输层：_抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel, Transporter, Client, Server, Codec</p>
<p>_serialize 数据序列化层：_可复用的一些工具，扩展接口为 Serialization, ObjectInput, ObjectOutput, ThreadPool</p>
<h3 id="主要模块">主要模块</h3>
<p><code>dubbo-common</code> 公共逻辑模块，包括 <code>Util</code> 类和<strong>通用模型</strong>。</p>
<p><code>dubbo-remoting</code> 远程通讯模块，相当于 Dubbo 协议的<strong>实现</strong>，如果 RPC 用 RMI 协议则不需要使用此包。</p>
<p><code>dubbo-rpc</code> 远程调用模块，抽象各种协议，以及动态代理，只包含<strong>一对一的调用</strong>，不关心集群的管理。</p>
<p><code>dubbo-cluster</code> 集群模块，将多个服务提供方<strong>伪装为一个提供方</strong>，包括：负载均衡、容错、路由等，集群的地址列表可以是静态配置的，也可以是由注册中心下发。</p>
<p><code>dubbo-registry</code> 注册中心模块，基于注册中心下发地址的<strong>集群方式</strong>，以及对各种注册中心的抽象。</p>
<p><code>dubbo-monitor</code> 监控模块，<strong>统计服务调用</strong>次数，调用时间的，调用链跟踪的服务。</p>
<p><code>dubbo-config</code> 配置模块，是 Dubbo <strong>对外</strong>的 API ，用户通过 Config 使用 Dubbo ，隐藏 Dubbo 所有细节。</p>
<p><code>dubbo-container</code> 容器模块，是一个 <code>Standalone</code> 的容器，以简单的 Main <strong>加载</strong> Spring 启动，因为服务通常不需要 Tomcat/JBoss 等 Web 容器的特性，没必要用 Web 容器去加载服务。<br>
<img src="https://img2020.cnblogs.com/blog/1613154/202103/1613154-20210329111700358-1356604720.png" alt="image" loading="lazy"><br>
主要模块</p>
<h3 id="调用方式">调用方式</h3>
<h4 id="异步调用">异步调用</h4>
<p>基于 NIO 的非阻塞实现<strong>并行调用</strong>，客户端不需要启动多线程即可完成并行调用多个远程服务，相对多线程开销较小<br>
<img src="https://img2020.cnblogs.com/blog/1613154/202103/1613154-20210329111726927-601588592.png" alt="image" loading="lazy"><br>
异步调用</p>
<h4 id="本地调用">本地调用</h4>
<p>使用了Injvm协议，是一个伪协议，它不开启端口，不发起远程调用，只在JVM内直接关联，但执行Dubbo的Filter链。</p>
<p>Define injvm protocol:</p>
<pre><code>&lt;dubbo:protocol&nbsp;name="injvm"&nbsp;/&gt; 
</code></pre>
<p>Set default protocol:</p>
<pre><code>`&lt;dubbo:provider&nbsp;protocol="injvm"&nbsp;/&gt;`

</code></pre>
<p>Set service protocol:</p>
<pre><code>&lt;dubbo:service&nbsp;protocol="injvm"&nbsp;/&gt;
</code></pre>
<p>Use injvm first:（服务暴露与服务引用都需要声明injvm=“true”）</p>
<pre><code>`&lt;dubbo:consumer&nbsp;injvm="true"&nbsp;.../&gt;`
`&lt;dubbo:provider&nbsp;injvm="true"&nbsp;.../&gt;`
`或`
`&lt;dubbo:reference&nbsp;injvm="true"&nbsp;.../&gt;&nbsp;　　&lt;dubbo:service&nbsp;injvm="true"&nbsp;.../&gt;`
</code></pre>
<h3 id="容错机制">容错机制</h3>
<h4 id="调用流程">调用流程</h4>
<p>_1、_Cluster 将 Directory 中的多个 Invoker 伪装成一个Invoker，对上层透明，伪装过程包含了<strong>容错逻辑</strong></p>
<p>_2、_Router 负责从多个 Invoker 中按<strong>路由规则</strong>选出子集，比如读写分离，应用隔离等</p>
<p>_3、_LoadBalance 负责从多个 Invoker 中选出具体的一个用于本次调用，选的过程包含了<strong>负载均衡</strong>算法<br>
<img src="https://img2020.cnblogs.com/blog/1613154/202103/1613154-20210329120258304-1147780029.png" alt="image" loading="lazy"><br>
调用流程</p>
<h4 id="容错策略">容错策略</h4>
<p>Dubbo 官网提出总共有六种容错策略</p>
<p>_1、_Failover Cluster</p>
<p><strong>失败自动切换</strong>，当出现失败，重试其它服务器。(默认)</p>
<p>_2、_Failfast Cluster</p>
<p><strong>快速失败</strong>，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</p>
<p>_3、_Failsafe Cluster</p>
<p><strong>失败安全</strong>，出现异常时，直接忽略。通常用于写入审计日志等操作。</p>
<p>_4、_Failback Cluster</p>
<p><strong>失败自动恢复</strong>，后台记录失败请求，定时重发。通常用于消息通知操作。</p>
<p>_5、_Forking Cluster</p>
<p><strong>并行调用多个服务器，只要一个成功即返回</strong>。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。<br>
可通过 forks=”2”来设置最大并行数。</p>
<p>_6、_Broadcast Cluster</p>
<p><strong>广播调用所有提供者，逐个调用，任意一台报错则报错</strong>。(2.1.0 开始支持) 通常用于通知所有提供者更新缓存或日志等本地资源信息。</p>
<p>总结：在实际应用中<strong>查询语句</strong>容错策略建议使用默认 <code>Failover Cluster</code>，而<strong>增删改</strong>建议使用 <code>Failfast Cluster</code> 或者使用 <code>Failover Cluster</code>（retries=”0”）策略，防止出现数据重复添加等等其它问题！建议在设计接口时候把查询接口方法<strong>单独做一个接口</strong>提供查询。</p>
<h3 id="连接方式">连接方式</h3>
<p>Dubbo 的客户端和服务端有三种连接方式，分别是：<strong>广播、直连</strong>和使用<code>Zookeeper</code>注册中心。</p>
<h4 id="dubbo-广播">Dubbo 广播</h4>
<p>这种方式是dubbo官方入门程序所使用的连接方式，但是这种方式有很多问题，在企业开发中不使用广播的方式。</p>
<p><em>服务端配置：</em></p>
<pre><code>`&lt;!--配制dubbo--&gt;`
`&lt;!--提供应用信息，用于计算依赖关系--&gt;`
`&lt;dubbo:application&nbsp;name="demo-service"/&gt;`
`&lt;!--使用multicast广播注册暴露服务地址--&gt;`
`&lt;dubbo:registry&nbsp;address="multicast://192.168.9.4:88888"&nbsp;/&gt;`
`&lt;!--使用dubbo协议在20880端口暴露服务--&gt;`
`&lt;dubbo:protocol&nbsp;name="dubbo"&nbsp;port="20880"/&gt;`
`&lt;!--声明暴露的服务接口--&gt;`
`&lt;dubbo:service&nbsp;interface="com.demo.manger.service.TestService"&nbsp;ref="testServiceImpl"&nbsp;/&gt;`

</code></pre>
<p><em>客户端配置：</em></p>
<pre><code>`&lt;!--配合dubbo--&gt;`
`&lt;!--提供应用信息，用于计算依赖关系--&gt;`
`&lt;dubbo:application&nbsp;name="demo-web"/&gt;`
`&lt;!--使用multicast广播注册中心暴露服务地址&nbsp;--&gt;`
`&lt;dubbo:registry&nbsp;address="multicast://19.188.8.9:8888"/&gt;`
`&lt;!--声明需要暴露的接口--&gt;`
`&lt;dubbo:reference&nbsp;interface="com.demo.manager.service.TestService"&nbsp;id="testService"&nbsp;timeout="1000000"&nbsp;/&gt;`

</code></pre>
<h4 id="dubbo-直连">Dubbo 直连</h4>
<p>这种方式在企业中一般在开发中环境中使用，但是生产环境很少使用，因为服务是直接调用，没有使用注册中心，很难对服务进行管理。Dubbo 直连，首先要取消广播，然后客户端直接到指定需要的服务的 url 获取服务即可。</p>
<p><em>服务端配置：</em></p>
<pre><code>`&lt;!--配制dubbo--&gt;`
`&lt;!--提供应用信息，用于计算依赖关系--&gt;`
`&lt;dubbo:application&nbsp;name="demo-service"/&gt;`
`&lt;!--使用multicast广播注册暴露服务地址--&gt;`
`&lt;--&nbsp;&lt;dubbo:registry&nbsp;address="multicast://192.168.9.4:88888"&nbsp;/&gt;&nbsp;--&gt;`
`&lt;dubbo:registry&nbsp;adress="N/A"&gt;`
`&lt;!--使用dubbo协议在20880端口暴露服务--&gt;`
`&lt;dubbo:protocol&nbsp;name="dubbo"&nbsp;port="20880"/&gt;`
`&lt;!--声明暴露的服务接口--&gt;`
`&lt;dubbo:service&nbsp;interface="com.demo.manger.service.TestService"&nbsp;ref="testServiceImpl"&nbsp;/&gt;`

</code></pre>
<p><em>客户端配置：</em></p>
<pre><code>`&lt;!--配合dubbo--&gt;`
`&lt;!--提供应用信息，用于计算依赖关系--&gt;`
`&lt;dubbo:application&nbsp;name="demo-web"/&gt;`
`&lt;!--使用multicast广播注册中心暴露服务地址&nbsp;--&gt;`
`&lt;--&nbsp;&lt;dubbo:registry&nbsp;address="multicast://19.188.8.9:8888"/&gt;&nbsp;--&gt;`
`&lt;!--声明需要暴露的接口--&gt;`
`&lt;dubbo:reference&nbsp;interface="com.demo.manager.service.TestService"&nbsp;id="testService"&nbsp;timeout="1000000"&nbsp;url="dubbo://127.0.0.1:20880"&nbsp;/&gt;`

</code></pre>
<h4 id="zookeeper-注册中心">zookeeper 注册中心</h4>
<p>Dubbo 注册中心和广播注册中心配置类似，不过需要指定注册中心类型和注册中心地址，这个时候就不是把服务信息进行广播了，而是告诉给注册中心进行管理，这个时候我们就需要有一个注册中心，<strong>官方推荐</strong>使用 zookeeper 作为注册中心。<br>
<img src="https://img2020.cnblogs.com/blog/1613154/202103/1613154-20210329111904308-1497611577.png" alt="image" loading="lazy"><br>
Zookeeper 注册中心</p>
<p>注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者在启动时与注册中心交互，消费者不断的发起请求获取服务信息，注册中心不转发请求，压力较小</p>
<p><em>服务端配置：</em></p>
<pre><code>`&lt;!--配制dubbo--&gt;`
`&lt;!--提供应用信息，用于计算依赖关系--&gt;`
`&lt;dubbo:application&nbsp;name="demo-service"/&gt;`
`&lt;!--使用multicast广播注册暴露服务地址--&gt;`
`&lt;!--&nbsp;&lt;dubbo:registry&nbsp;address="multicast://192.168.9.4:88888"&nbsp;/&gt;&nbsp;--&gt;`
`&lt;!--&lt;dubbo:registry&nbsp;adress="N/A"&gt;&nbsp;--&gt;`
`&lt;dubbo:registry&nbsp;protocol="zookeeper"&nbsp;address="192.168.37,136:2181"&gt;`
`&lt;!--使用dubbo协议在20880端口暴露服务--&gt;`
`&lt;dubbo:protocol&nbsp;name="dubbo"&nbsp;port="20880"/&gt;`
`&lt;!--声明暴露的服务接口--&gt;`
`&lt;dubbo:service&nbsp;interface="com.demo.manger.service.TestService"&nbsp;ref="testServiceImpl"&nbsp;/&gt;`

</code></pre>
<p><em>客户端配置：</em></p>
<pre><code>`&lt;!--配合dubbo--&gt;`
`&lt;!--提供应用信息，用于计算依赖关系--&gt;`
`&lt;dubbo:application&nbsp;name="demo-web"/&gt;`
`&lt;!--使用multicast广播注册中心暴露服务地址&nbsp;--&gt;`
`&lt;--&nbsp;&lt;dubbo:registry&nbsp;address="multicast://19.188.8.9:8888"/&gt;&nbsp;--&gt;`
`&lt;dubbo:registry&nbsp;protocol="zookeeper"&nbsp;address="192.168.37.1336:2181"/&gt;` 
`&lt;!--声明需要暴露的接口--&gt;`
`&lt;dubbo:reference&nbsp;interface="com.demo.manager.service.TestService"&nbsp;id="testService"&nbsp;timeout="1000000"&nbsp;/&gt;`
</code></pre>
<h3 id="策略">策略</h3>
<h4 id="负载均衡策略">负载均衡策略</h4>
<p>_1、_Random LoadBalance，<strong>随机</strong>（默认的负载均衡策略）</p>
<p>RandomLoadBalance 是加权随机算法的具体实现，可以完全随机，也可以按权重设置随机概率。</p>
<p>_2、_RoundRobin LoadBalance，<strong>轮循</strong></p>
<p>可以轮询和加权轮询。存在响应慢的提供者会累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</p>
<p>_3、_LeastActive LoadBalance，<strong>最少活跃调用数</strong></p>
<p>活跃调用数越小，表明该服务提供者效率越高，单位时间内可处理更多的请求。此时应优先将请求分配给该服务提供者。</p>
<p>_4、_ConsistentHash LoadBalance，<strong>一致性 Hash</strong></p>
<p>一致性 Hash 算法，相同参数的请求一定分发到一个 provider 上去。provider 挂掉的时候，会基于虚拟节点均匀分配剩余的流量，抖动不会太大。</p>
<h4 id="集群容错策略">集群容错策略</h4>
<p>_1、_failover cluster（默认）</p>
<p><strong>失败自动切换</strong>，调用失败时，自动重试其他机器。通常用于读操作，但重试会带来更长延迟。</p>
<p>_2、_Failfast Cluster<br>
<strong>快速失败</strong>，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</p>
<p>_3、_Failsafe Cluster<br>
<strong>失败安全</strong>，出现异常时，直接忽略。通常用于写入审计日志等操作。</p>
<p>_4、_Failback Cluster<br>
<strong>失败自动恢复</strong>，后台记录失败请求，定时重发。通常用于消息通知操作。</p>
<p>_5、_Forking Cluster<br>
<strong>并行调用多个服务器，只要一个成功即返回</strong>。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。</p>
<h4 id="动态代理策略">动态代理策略</h4>
<p>默认使用 <code>javassist</code> 动态字节码生成，创建代理类。也可以通过 spi 扩展机制配置自己的动态代理策略。</p>
<h3 id="集群容错方案">集群容错方案</h3>
<ul>
<li>配置说明，方案配置方式，优先使用<strong>消费端配置</strong></li>
</ul>
<pre><code>`&lt;!--服务端配置--&gt;`
`&lt;dubbo:service&nbsp;cluster="failover"/&gt;`
`&lt;!--消费端配置--&gt;`
`&lt;dubbo:reference&nbsp;cluster="failover"/&gt;`

</code></pre>
<ul>
<li>
<p>尽量在只在服务端进行配置</p>
</li>
<li>
<p>cluster类型均为小写</p>
</li>
<li>
<p>默认为FailoverCluster失败切换方案</p>
</li>
</ul>
<h4 id="集群容错方案support">集群容错方案support</h4>
<p><em>FailoverCluster（默认）：失败切换</em></p>
<ul>
<li>
<p>场景：调用失败后<strong>切换</strong>其他服务</p>
</li>
<li>
<p>配置：</p>
</li>
</ul>
<pre><code>`&lt;!--`
`retries:重试次数，不包括第一次，默认2次`
`--&gt;`
`&lt;dubbo:service&nbsp;cluster="failover"&nbsp;retries="3"/&gt;`

</code></pre>
<ul>
<li>
<p>代码实现逻辑：</p>
<p><em>1.</em> 根据负载均衡策略选出需要调用的服务实例，排除已调用的</p>
<p><em>2.</em> 执行选出的实例，并将其保存到已调用列表中</p>
<p><em>3.</em> 执行实例成功即返回</p>
<p><em>4.</em> 执行实例不成功，为到最大重试次数则执行第一步，否则抛出RpcException异常</p>
</li>
</ul>
<h4 id="failbackcluster：失败重试">FailbackCluster：失败重试</h4>
<ul>
<li>
<p>场景：调用失败时<strong>记录</strong>失败请求，定时重发</p>
</li>
<li>
<p>配置：</p>
</li>
</ul>
<pre><code>`&lt;!--`
`retries:重试次数，不包括第一次，默认3次`
`failbacktasks:定时器中最大挂起任务数，默认100`
`--&gt;`
`&lt;dubbo:service&nbsp;cluster="failback"&nbsp;retries="5"&nbsp;failbacktasks="200"/&gt;`

</code></pre>
<ul>
<li>
<p>代码实现逻辑</p>
<p><em>1.</em> 根据负载均衡策略选出需要调用的服务实例</p>
<p><em>2.</em> 执行选出的实例</p>
<p><em>3.</em> 执行实例成功即返回</p>
<p><em>4.</em> 执行异常则创建延时5秒的定时任务，并加入时间轮定时器，第一次需要进行<strong>定时器初始化</strong>，分为32个时间片，每1秒滚动一次，最大挂起任务默认100个，超出最大任务数时抛出RejectedExecutionException异常。</p>
<p><em>5.</em> 重试执行定时任务，次数超出最大执行次数停止，并输出error日志，默认为3次。</p>
</li>
</ul>
<h4 id="failfastcluster：快速失败">FailfastCluster：快速失败</h4>
<ul>
<li>
<p>场景：调用失败<strong>立即</strong>报错</p>
</li>
<li>
<p>配置：</p>
</li>
</ul>
<pre><code>`&lt;dubbo:service&nbsp;cluster="failfast"/&gt;`

</code></pre>
<ul>
<li>
<p>代码实现逻辑</p>
<p><em>1.</em> 根据负载均衡策略选出需要调用的服务实例</p>
<p><em>2.</em> 执行选出的实例</p>
<p><em>3.</em> 执行实例成功即返回，失败抛出RpcException异常</p>
</li>
</ul>
<h4 id="failsafecluster：安全失败">FailsafeCluster：安全失败</h4>
<ul>
<li>
<p>场景：调用失败后<strong>忽略</strong></p>
</li>
<li>
<p>配置：</p>
</li>
</ul>
<pre><code>`&lt;dubbo:service&nbsp;cluster="failsafe"/&gt;`

</code></pre>
<ul>
<li>
<p>代码实现逻辑</p>
<p><em>1.</em> 根据负载均衡策略选出需要调用的服务实例</p>
<p><em>2.</em> 执行选出的实例</p>
<p><em>3.</em> 执行实例成功即返回，失败输出error日志，并返RpcResult，视为忽略。</p>
</li>
</ul>
<h4 id="forkingcluster：并发处理">ForkingCluster：并发处理</h4>
<ul>
<li>
<p>场景：并发调用指定数量的服务，一个成功则返回，对<strong>实时性要求高</strong>的场景，要求快速返回，需要使用更多服务器资源。</p>
</li>
<li>
<p>配置：</p>
</li>
</ul>
<pre><code>`&lt;!--`
`forks:最大并发数,默认2`
`timeout:并发返回超时时间，默认1000ms`
`--&gt;`
`&lt;dubbo:service&nbsp;cluster="forking"&nbsp;forks="3"&nbsp;timeout="500"/&gt;`

</code></pre>
<ul>
<li>
<p>代码实现逻辑</p>
<p><em>1.</em> 根据负载均衡策略选出几个不同的服务实例</p>
<p><em>2.</em> 并发执行选出的几个实例，并将返回结果放入堵塞队列中</p>
<p><em>3.</em> 返回堵塞队列中的第一个值，如规定时间内未获取到队列中的值或获取到异常值则返回RPC异常。</p>
</li>
</ul>
<h4 id="broadcastcluster：广播">BroadcastCluster：广播</h4>
<ul>
<li>
<p>场景：广播方式逐个调用服务提供者，有一个报错则返回错误，多用于通知服务提供者<strong>更新</strong>本地资源信息，如缓存，日志等。</p>
</li>
<li>
<p>配置：</p>
</li>
</ul>
<pre><code>`&lt;dubbo:service&nbsp;cluster="broadcast"/&gt;`

</code></pre>
<ul>
<li>
<p>代码实现逻辑</p>
<p><em>1.</em> 循环逐个执行所有服务实例信息</p>
<p><em>2.</em> 保存一份返回结果和异常信息</p>
<p><em>3.</em> 执行完全部实例后，如异常信息不为空，则抛出异常信息，否则返回最后一个实例的结果。</p>
</li>
</ul>
<h4 id="availablecluster：可用服务">AvailableCluster：可用服务</h4>
<ul>
<li>
<p>场景：调用<strong>第一个可用</strong>服务</p>
</li>
<li>
<p>配置：</p>
</li>
</ul>
<pre><code>`&lt;dubbo:service&nbsp;cluster="available"/&gt;`

</code></pre>
<ul>
<li>
<p>代码实现逻辑</p>
<p><em>1.</em> 循环所有服务实例信息</p>
<p><em>2.</em> 执行第一个可用的实例，并返回结果</p>
<p><em>3.</em> 如无可用实例则返回RpcException异常</p>
</li>
</ul>
<h4 id="mergeablecluster：合并处理">MergeableCluster：合并处理</h4>
<ul>
<li>
<p>场景：返回<strong>合并</strong>或叠加处理结果</p>
</li>
<li>
<p>配置：</p>
</li>
</ul>
<pre><code>`&lt;!--`
`merger:合并发放名`
`timeout:调用服务超时时间，默认1000ms`
`--&gt;`
`&lt;dubbo:service&nbsp;cluster="mergeable"&nbsp;merger="true"&nbsp;timeout="500"/&gt;`

</code></pre>
<ul>
<li>
<p>代码实现逻辑</p>
<p><em>1.</em> 判断merger，为空、null、0、false、N/A是执行第一个可用服务并返回结果，无可用则执行第一个实例，并返回结果。</p>
<p><em>2.</em> 获取方法实例的返回类型</p>
<p><em>3.</em> 异步调用所有实例，并将异步结果Result存储到结果集中，返回异常输出error日志</p>
<p><em>4.</em> 结果集为空返回 RpcException，大小为 1时返回第一个Result</p>
<p><em>5.</em> 当merger的第一个字符为“.”时，判断当 merger 实例返回类型不为void,且返回类型必须是结果集中第一个返回类型的<strong>父类型或相同类型</strong>时，循环执行merger实例，每一次都传入上一次的返回结果，最终返回获取最后一次结果，非上述情况时循环执行merger实例，返回结果集中的第一个结果。</p>
<p><em>6.</em> 当merger为true或default时使用Dubbo默认合并器，否则使用自定义merger合并器，合并后返回</p>
</li>
</ul>
<h4 id="registryawarecluster默认标识、注册标识">RegistryAwareCluster:默认标识、注册标识</h4>
<ul>
<li>
<p>场景：调用注册<strong>默认</strong>标识的服务</p>
</li>
<li>
<p>配置：</p>
</li>
</ul>
<pre><code>`&lt;!--`
`default:默认标识`
`--&gt;`
`&lt;dubbo:registry&nbsp;address="zookeeper://xxx..."&nbsp;default="true"/&gt;`
`&lt;dubbo:service&nbsp;cluster="registryaware"/&gt;`

</code></pre>
<ul>
<li>
<p>代码实现逻辑</p>
<p><em>1.8</em> 循环所有服务实例信息</p>
<p><em>2.</em> 执行第一个可用的实例且default为true的实例</p>
<p><em>3.</em> 无默认实例则执行第一个可用的实例</p>
<p><em>4.</em> 无可用的实例则抛出RpcException异常</p>
</li>
</ul>
<h3 id="主要配置">主要配置</h3>
<p>配置应用信息：</p>
<pre><code>`&lt;dubbo:application&nbsp;name=“appName-provider”&nbsp;/&gt;`

</code></pre>
<p>配置注册中心相关信息：</p>
<pre><code>`&lt;dubbo:registryid=“zk”&nbsp;protocol=“zookeeper”&nbsp;address=“127.0.0.1:2181”&nbsp;/&gt;`

</code></pre>
<p>配置服务协议：</p>
<pre><code>`&lt;dubbo:protocol&nbsp;name=“dubbo”&nbsp;port=“20880”&nbsp;threadpool=“cached”&nbsp;threads=“80”&nbsp;/&gt;`

</code></pre>
<p>配置所有暴露服务缺省值：</p>
<pre><code>`&lt;dubbo:provider&nbsp;registry=“zk”&nbsp;protocol=“dubbo”&nbsp;retries=“0”&nbsp;version=“1.0.0”&nbsp;timeout=“3000”&nbsp;threadpool=“cached”&nbsp;threads=“4”/&gt;`

</code></pre>
<p>配置暴露服务：</p>
<pre><code>`&lt;dubbo:service&nbsp;interface=“com.orgname.app.serviceX”&nbsp;ref=“serviceX”&nbsp;/&gt;`

</code></pre>
<p>配置所有引用服务缺省值：</p>
<pre><code>`&lt;dubbo:consumer&nbsp;check=“false”&nbsp;timeout=“1000”&nbsp;version=“1.0”&nbsp;retries=“0”&nbsp;async=“false”&nbsp;/&gt;`

</code></pre>
<p>注解配置：</p>
<pre><code>`com.alibaba.dubbo.config.annotation.Service&nbsp;配置暴露服务`
`com.alibaba.dubbo.config.annotation.Reference配置引用服务`

</code></pre>
<h3 id="超时设置">超时设置</h3>
<h4 id="dubbo消费端">Dubbo消费端</h4>
<p>全局超时配置</p>
<pre><code>`&lt;dubbo:consumer&nbsp;timeout="5000"&nbsp;/&gt;`

</code></pre>
<p>指定接口以及特定方法超时配置</p>
<pre><code>`&lt;dubbo:reference&nbsp;interface="com.foo.BarService"&nbsp;timeout="2000"&gt;`
 `&lt;dubbo:method&nbsp;name="sayHello"&nbsp;timeout="3000"&nbsp;/&gt;`
`&lt;/dubbo:reference&gt;`

</code></pre>
<h4 id="dubbo服务端">Dubbo服务端</h4>
<p>全局超时配置</p>
<pre><code>`&lt;dubbo:provider&nbsp;timeout="5000"&nbsp;/&gt;`

</code></pre>
<p>指定接口以及特定方法超时配置</p>
<pre><code>`&lt;dubbo:provider&nbsp;interface="com.foo.BarService"&nbsp;timeout="2000"&gt;`
 `&lt;dubbo:method&nbsp;name="sayHello"&nbsp;timeout="3000"&nbsp;/&gt;`
`&lt;/dubbo:provider&gt;`

</code></pre>
<h3 id="支持协议">支持协议</h3>
<p>_1、_Dubbo 协议(官方推荐协议)</p>
<p>优点：采用NIO复用单一长连接，并使用线程池并发处理请求，减少握手和加大并发效率，<strong>性能较好</strong>（推荐使用）</p>
<p>缺点：<strong>大文件</strong>上传时,可能出现问题(不使用 Dubbo 文件上传)</p>
<p>_2、_RMI(Remote Method Invocation)协议</p>
<p>优点:JDK <strong>自带</strong>的能力。可与原生 RMI 互操作，基于 TCP 协议</p>
<p>缺点:<strong>偶尔连接失败</strong>.</p>
<p>_3、_Hessian协议</p>
<p>优点:可与<strong>原生</strong> Hessian 互操作，基于 HTTP 协议</p>
<p>缺点:需 hessian.jar 支持，http 短连接的*_开销大_8</p>
<h3 id="常用设计模式">常用设计模式</h3>
<p>Dubbo 框架在初始化和通信过程中使用了多种设计模式，可灵活控制<strong>类加载、权限控制</strong>等功能。</p>
<h4 id="工厂模式">工厂模式</h4>
<p>Provider 在 export 服务时，会调用 ServiceConfig 的 export 方法。ServiceConfig 中有个字段：</p>
<pre><code>`private&nbsp;static&nbsp;final&nbsp;Protocol&nbsp;protocol&nbsp;=`
`ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();`

</code></pre>
<p>Dubbo 里有很多这种代码。这也是一种工厂模式，只是实现类的获取采用了 JDK SPI 的机制。这么实现的优点是<strong>可扩展性强</strong>，想要扩展实现，只需要在 classpath下增加个文件就可以了，代码零侵入。另外，像上面的 Adaptive 实现，可以做到调用时动态决定调用哪个实现，但是由于这种实现采用了动态代理，会造成代码调试<strong>比较麻烦</strong>，需要分析出实际调用的实现类。</p>
<h4 id="装饰器模式">装饰器模式</h4>
<p>Dubbo 在启动和调用阶段都大量使用了装饰器模式。以 Provider 提供的调用链为例，具体的调用链代码是在 ProtocolFilterWrapper 的buildInvokerChain 完成的，具体是将注解中含有 group=provider 的 Filter 实现，按照 order 排序，最后的调用顺序是：</p>
<pre><code>`EchoFilter&nbsp;-&gt;&nbsp;ClassLoaderFilter&nbsp;-&gt;&nbsp;GenericFilter&nbsp;-&gt;&nbsp;ContextFilter&nbsp;-&gt;`
`ExecuteLimitFilter&nbsp;-&gt;&nbsp;TraceFilter&nbsp;-&gt;&nbsp;TimeoutFilter&nbsp;-&gt;&nbsp;MonitorFilter&nbsp;-&gt;`
`ExceptionFilter`

</code></pre>
<p>更确切地说，这里是装饰器和责任链模式的<strong>混合使用</strong>。例如，EchoFilter 的作用是判断是否是回声测试请求，是的话直接返回内容，这是一种责任链的体现。而像ClassLoaderFilter 则只是在主功能上添加了功能，更改当前线程的 ClassLoader，这是典型的装饰器模式。</p>
<h4 id="观察者模式">观察者模式</h4>
<p>Dubbo 的 Provider 启动时，需要与注册中心<strong>交互</strong>，先注册自己的服务，再订阅自己的服务，订阅时，采用了观察者模式，开启一个 listener。注册中心会每 5 秒定时检查是否有服务更新，如果有更新，向该服务的提供者发送一个 notify 消息，provider 接受到 notify 消息后，即运行 NotifyListener 的 notify 方法，执行监听器方法。</p>
<h4 id="动态代理模式">动态代理模式</h4>
<p>Dubbo 扩展 JDK SPI 的类 ExtensionLoader 的 Adaptive 实现是典型的动态代理实现。Dubbo 需要灵活地控制实现类，即在调用阶段动态地根据参数决定调用哪个实现类，所以采用<strong>先生成代理类</strong>的方法，能够做到灵活的调用。生成代理类的代码是 ExtensionLoader 的 createAdaptiveExtensionClassCode 方法。代理类的主要逻辑是，获取 URL 参数中指定参数的值作为获取实现类的 key</p>
<h3 id="工作流程">工作流程</h3>
<p><em>整体流程：</em></p>
<p>第一步：provider 向注册中心去<strong>注册</strong></p>
<p>第二步：consumer 从注册中心订阅服务，注册中心会<strong>通知</strong> consumer 注册好的服务</p>
<p>第三步：consumer <strong>调用</strong> provider</p>
<p>第四步：consumer 和 provider 都<strong>异步通知</strong>监控中心<br>
<img src="https://img2020.cnblogs.com/blog/1613154/202103/1613154-20210329112012423-53007713.png" alt="image" loading="lazy"><br>
流程图</p>
<h3 id="总结">总结</h3>
<p>最后用一张图来形象的模拟 Dubbo 的使用：<br>
<img src="https://img2020.cnblogs.com/blog/1613154/202103/1613154-20210329112028330-782137355.png" alt="image" loading="lazy"><br>
使用</p>
<p>以上只是我总结的一些关于 dubbo 最基础的原理及使用介绍，至于代码编写过程的 bug 处理经验，环境搭建、项目布局等等问题，需要我们在平时开发中，将<strong>系统知识与实战经验</strong>相结合去总结，这样才能真正的去掌握这项技术点。</p>
<p>Dubbo 目前是我用到过的最多的分布式框架，写出来的内容也是最多的，不过由于Dubbo用的太多，而 SpringCloud 难度比 Dubbo 要小很多，现在大部分项目都即将开始转投到了 SpringCloud 上面，后面也会出更多的 SpringCloud 相关的文章。</p>

</div>
<div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
    <div id="blog_post_info"></div>
    <div class="clear"></div>
    <div id="post_next_prev"></div>
</div>
            </div>
            <div class="postDesc">posted @ 
<span id="post-date">2021-03-29 11:33</span>&nbsp;
<a href="https://www.cnblogs.com/qianyueric/">浅羽技术</a>&nbsp;
阅读(<span id="post_view_count">933</span>)&nbsp;
评论(<span id="post_comment_count">6</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=14591684" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(14591684);return false;">收藏</a></div>
        </div>
	    
	    
    </div><!--end: topics 文章、评论容器-->
</div>
<script src="https://common.cnblogs.com/highlight/10.3.1/highlight.min.js"></script>
<script>markdown_highlight();</script>
<script>
    var allowComments = true, cb_blogId = 655084, cb_blogApp = 'qianyueric', cb_blogUserGuid = 'f78bbd12-2966-4cf7-99e5-08d69bd2885c';
    var cb_entryId = 14591684, cb_entryCreatedDate = '2021-03-29 11:33', cb_postType = 1;
    updatePostStats(
        [cb_entryId],
        function(id, count) { $("#post_view_count").text(count) },
        function(id, count) { $("#post_comment_count").text(count) })
    zoomManager.apply("#cnblogs_post_body img:not(.code_img_closed):not(.code_img_opened)");
</script>
<a name="!comments"></a>
<div id="blog-comments-placeholder"></div>
<div id="comment_form" class="commentform">
    <a name="commentform"></a>
    <div id="divCommentShow"></div>
    <div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" onclick="return RefreshCommentList();" id="lnk_RefreshComments" runat="server" clientidmode="Static">刷新评论</a><a href="#" onclick="return RefreshPage();">刷新页面</a><a href="#top">返回顶部</a></div>
    <div id="comment_form_container"></div>
    <div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
    <div id="ad_t2"></div>
    <div id="opt_under_post"></div>
    <div id="cnblogs_c1" class="under-post-card">
        <div id='div-gpt-ad-1592365906576-0' style='width: 300px; height: 250px;'></div>
    </div>
    <div id="under_post_card1"></div>
    <div id="cnblogs_c2" class="under-post-card">
        <div id='div-gpt-ad-1592366332455-0' style='width: 468px; height: 60px;'></div>
    </div>
    <div id="under_post_card2"></div>
    <div id="HistoryToday" class="under-post-card"></div>
    <script type="text/javascript">
       var commentManager = new blogCommentManager();
       commentManager.renderComments(0);
       fixPostBody();
       deliverBigBanner();
setTimeout(function() { incrementViewCount(cb_entryId); }, 50);       deliverT2();
       deliverC1C2();
       loadNewsAndKb();
       loadBlogSignature();
LoadPostCategoriesTags(cb_blogId, cb_entryId);       LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
       GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
       loadOptUnderPost();
       GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);
    </script>
</div>

	</div><!--end: forFlow -->
	</div><!--end: mainContent 主体内容容器-->
	<div id="sideBar">
		<div id="sideBarMain">
			<div id="sidebar_news" class="newsItem">
            <script>loadBlogNews();</script>
</div>
<div id="sidebar_c3"></div>
			<div id="blog-calendar" style="display:none"></div><script>loadBlogDefaultCalendar();</script>			
			<div id="leftcontentcontainer">
				<div id="blog-sidecolumn"></div>
                    <script>loadBlogSideColumn();</script>
			</div>			
		</div><!--end: sideBarMain -->
	</div><!--end: sideBar 侧边栏容器 -->
	<div class="clear"></div>
	</div><!--end: main -->
	<div class="clear"></div>
	<div id="footer">
		<!--done-->
Copyright &copy; 2021 浅羽技术
<br /><span id="poweredby">Powered by .NET 5.0 on Kubernetes</span>



	</div><!--end: footer -->
</div><!--end: home 自定义的最大容器 -->


    

    <input type="hidden" id="antiforgery_token" value="CfDJ8L-rpLgFVEJMgssCVvNUAjtODF9S-l7ZGFSq_Q1jYO9BJV7pYL438sBeCekjUmlF2qBckkQWPTveeIc7n3O8YHvuIIp2xX0FIH22U8_vX_KlMixVVswx4ybmUgLNaVY3YKQZdc1txJxREfhQvigv7vo" />
</body>
</html>
